---
title: Instrumenting Errors with Sentry
description: Instrumenting errors with Sentry
---

So we've got Sentry installed now; great. Let's get set up to properly capture errors. We're jumping right into the code! 

## Houston, We Have Several Problems

Picture this: You visit ErrorFix's marketplace, eager to solve some costly errors (oh, the irony), and... *tumbleweeds*. The product list is emptier than a developer's coffee cup at 4 PM. You click the heroic "Fix Me" button, hoping for salvation, and... *loading spinner of doom*. Then? Nothing. Nada. Zip.

![ErrorFix Marketplace](../../assets/img/8-error.gif)

Something's clearly wrong with our product system, but right now we're debugging blind. It's like trying to find a missing semicolon in the dark. 

## Understanding Sentry's Exception Capture

When errors occur in your application, you need more than just a console log. Sentry's exception capture provides rich context that helps you understand what went wrong and how to fix it.



## The Case of the Missing Products

Our ErrorFix app has two major crime scenes we need to investigate:

1. **The Ghost Town Marketplace** - Where products should be, but aren't
2. **The Infinite Loading Loop of Doom** - When clicking product links leads to... nowhere

Time to add some error tracking and figure out what's actually going wrong. The simplest way to capture an error with Sentry is using the `Sentry.captureException(error)` method:

```javascript
Sentry.captureException(error);
```

This method captures the error and sends it to Sentry, where it can be analyzed and reported.

### Step 1: The Products API Investigation

Let's open `/api/products/route.ts`. Here's what we're currently working with. In here, we're going to modify our `catch` block to capture the error with Sentry, **Uncomment line 4 to enable the import of Sentry, and uncomment line 41 to enable the error capture**:

```javascript
// this is line 4
// import * as Sentry from '@sentry/nextjs';
// ...
} catch (error) {
    console.error('Error in products API route:', error);
    
    // this is line 40-41
    // SENTRY-THIS: Cathing your exceptions!
    // Sentry.captureException(error);

    return NextResponse.json(
// ...
```

With that uncommented, we'll get high fiedlity error reports in Sentry for failures on this route. This includes the error message, stack trace, and other useful information.

```javascript

import * as Sentry from '@sentry/nextjs';
// ...
} catch (error) {
    console.error('Error in products API route:', error);
    Sentry.captureException(error);
    return NextResponse.json(
// ...
```

### Step 2: While were here... individual product details

Now for `/api/products/[id]/route.ts`, the route that's supposed to handle individual product details but is currently handling... well, disappointment. **We're going to uncomment line 4 and 66 to enable the error capture**:

```javascript
import { initDb } from '@/lib/db/db-server';
// this is line 4
// import * as Sentry from '@sentry/nextjs';
import { products } from '@/lib/data';

// ...
} catch (error) {
    console.error(`API error for product ${id}:`, error);
    
    // this is line 66
    // SENTRY-THIS: Cathing your exceptions!
    // Sentry.captureException(error);

    // Return standardized error response with more details
    return NextResponse.json(
// ...
```

## The Client-Side Saga

Now that our API routes are properly monitored, let's fix the client side‚Äîwhere our users are currently experiencing the digital equivalent of staring at a blank wall.

### Step 3: The Empty Marketplace Chronicle

In `/app/components/ClientProducts.tsx`, we'll upgrade our error handling from "¬Ø\\_(„ÉÑ)_/¬Ø" to actual error tracking:

```javascript
import * as Sentry from '@sentry/nextjs';

// Inside your component
useEffect(() => {
  const fetchProducts = async () => {
    try {
      const response = await fetch('/api/products');
      if (!response.ok) throw new Error('Failed to fetch products');
      const data = await response.json();
      setProducts(data.products);
    } catch (error) {
      // From "404 Not Found" to "404 and Here's Why"
      Sentry.captureException(error);
      setError('Failed to load products. Please try again later.');
      console.error('Error fetching products:', error);
    } finally {
      setLoading(false);
    }
  };

  fetchProducts();
}, []);
```

### Step 4: The Infinite Loading Loop Finale

Last but not least, let's fix `/app/components/ClientProductDetails.tsx` and its never-ending loading state:

```javascript
import * as Sentry from '@sentry/nextjs';

// Inside your component
useEffect(() => {
  const fetchProductDetails = async () => {
    try {
      const response = await fetch(`/api/products/${productId}`);
      if (!response.ok) throw new Error(`Failed to fetch product ${productId}`);
      const data = await response.json();
      setProduct(data.product);
    } catch (error) {
      // Time to catch that infinite loader in the act!
      Sentry.captureException(error);
      setError('Failed to load product details. Please try again later.');
      console.error('Error fetching product details:', error);
    } finally {
      setLoading(false);
    }
  };

  fetchProductDetails();
}, [productId]);
```

## The Moment of Truth

Now that we've added proper error tracking, let's see what's actually going wrong with our app:

1. Fire up the development server:
   ```bash
   npm run dev
   ```

2. Visit the marketplace page (prepare for disappointment‚Äîbut this time with tracking!)
   
3. Click that tempting "Fix Me" button (it still won't work, but now we'll know why)

4. Head over to your Sentry dashboard at [sentry.io](https://sentry.io)

And... *drumroll please*... you should now see detailed error reports flooding in! Stack traces, browser information, and all the juicy details about what's actually breaking our app.

## What Have We Accomplished?

By adding `Sentry.captureException(error)` to our catch blocks, we've:

1. Turned our 404s from mysteries into documented cases
2. Given our loading spinner a proper error reporting job
3. Created a paper trail for every failed API call
4. Made debugging feel less like fortune telling and more like detective work

## The Plot Thickens...

But wait! This is just the beginning of our error-tracking adventure. In the [next section](/tracing-performance/), we'll add even more context to our errors with custom breadcrumbs and tags. We'll also explore Sentry's performance monitoring to figure out why some of our components are moving slower than a sloth in a tar pit.

Remember: In the world of web development, errors are just plot twists waiting to be resolved. And now, thanks to Sentry, we've got front-row seats to the drama! üçø

